import { drawKeypoints, drawSkeleton } from "./draw";
import { Pose } from "@tensorflow-models/posenet";
import {
  CanvasRef,
  getVideoSize,
  isCanvas,
  isCanvasRef,
  isContext2D,
  isPose,
  isPoses,
  WebcamRef,
} from "../validations";
import React from "react";

export const drawSinglePerson = (
  pose: Pose | null | undefined,
  minConfidence: number,
  ctx: CanvasRenderingContext2D | null | undefined,
  scale = 1
) => {
  if (isContext2D(ctx) && isPose(pose)) {
    drawKeypoints(pose.keypoints, minConfidence, ctx, scale);
    drawSkeleton(pose.keypoints, minConfidence, ctx, scale);
  }
};

export const drawMultiPerson = (
  poses: Pose[] | null | undefined,
  minConfidence: number,
  ctx: CanvasRenderingContext2D | null | undefined,
  scale = 1
) => {
  if (isContext2D(ctx) && isPoses(poses)) {
    poses.forEach((pose) => drawSinglePerson(pose, minConfidence, ctx, scale));
  }
};

export const getCanvas2dCtx = (
  canvas?:
    | HTMLCanvasElement
    | React.MutableRefObject<HTMLCanvasElement | null | undefined>
) => {
  if (isCanvasRef(canvas)) {
    return canvas.current.getContext("2d");
  } else if (isCanvas(canvas)) {
    return canvas.getContext("2d");
  } else {
    return null;
  }
};


/**
 * @param: canvas or ref generated by const ref=useRef(null);
 * @returns: [canvas.width:number, canvas.height:number] or [null, null] if the input type is invalid
 */
export const getCanvasWH = (
  canvas?:
    | HTMLCanvasElement
    | React.MutableRefObject<HTMLCanvasElement | null | undefined>
) => {
  if (isCanvasRef(canvas)) {
    return [canvas.current.width, canvas.current.height] as const;
  }
  else if (isCanvas(canvas)) {
    return [canvas.width, canvas.height] as const;
  }
  else return [null, null] as const;
};


/**
 *
 * @param: canvas or ref generated by const ref=useRef(null);
 *
 * Clear canvas. if canvas type is invalid do nothing
 */
export const clearCanvas = (
    canvas?:
        | HTMLCanvasElement
        | React.MutableRefObject<HTMLCanvasElement | null | undefined>
) => {
  if (!canvas) return;
  const ctx = getCanvas2dCtx(canvas);
  const [width, height] = getCanvasWH(canvas);
  width && height && ctx?.clearRect(0, 0, width, height);
};

export const setCanvasSizeFromWebcam = (webcamRef:WebcamRef, canvasRef:CanvasRef) => {
  if (!webcamRef || !canvasRef || !isCanvas(canvasRef.current)) return;
  const [ videoWidth, videoHeight ] = getVideoSize(webcamRef);
  if (videoWidth && videoHeight) {
    canvasRef.current.width = videoWidth;
    canvasRef.current.height = videoHeight;
  } else {
    return;
  }
}
